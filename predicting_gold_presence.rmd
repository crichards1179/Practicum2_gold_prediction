---
title: "predicting_gold_presence"
author: "Matt Twigg"
date: "7/12/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Introduction  

	I used to live in the Black Hills and would go gold panning for relaxation. I never found any gold, unfortunately. It occurs to me that if I use data science techniques, I might be able to predict where to find gold. I plan to use data sets from https://mrdata.usgs.gov/mrds/geo-inventory.php for Lawrence County, South Dakota to predict whether gold can be found in the area of other minerals. If gold shows up with certain other minerals, I can narrow down the areas that I pan for gold. I will use support vector machine classification to predict gold or no gold.

My specific research question is “Can the presence of gold be predicted from the presence of other minerals?” The USGS is a great resource for understanding where minerals were found and what minerals were present.

This is a classification task. I will be predicting if the location has gold or not based on the minerals in that area. These data sets give latitude, longitude, and mineral data for given locations. I will create a train/test split to test for accuracy. The data sets have missing values, characters, and multiple pieces of information in single fields. The data will have to be cleaned and prepped in order to be useful. Multiple data sets will have to be combined into one data frame. Multiple rows will have to be dropped and only some fields selected. I will be using Rstudio to work with the data sets and storing the rmarkdown on GitHub. 

```{r}
library(ggplot2)
library(tidyverse)
library(dplyr)
library(corrplot)
library(factoextra)
```

```{r}
dn <- read.csv("deadwoodnorth.csv")
ds <- read.csv("deadwoodsouth.csv")
ld <- read.csv("lead.csv")
tn <- read_csv("tinton.csv")
sp <- read_csv("spearfish.csv")
```



```{r}
sites <- rbind(dn, ds, ld, tn, sp)
sites
```




```{r}
s1 <- sites %>% select(
  dep_id,
  site_name,
  latitude,
  longitude,
  commod1,
  commod2,
  commod3,
)
```


```{r}
s2 <- data.frame(s1)
```


```{r}
s2$commod2 <- as.factor(s2$commod2)
```

```{r}
str(s2)
```
```{r}
s2com <- unite(s2, commodities, 5:7, sep = ", ")
str(s2com)
```

```{r}
au <- str_detect(s2com$commodities, "Gold")
#au
```

```{r}
s2com1 <- cbind(s2com, au)
#s2com1
```

```{r}
reds2com <- subset(s2com1, au == TRUE)
reds2comF <- subset(s2com1, au == FALSE)
reds <- rbind(reds2com, reds2comF)
reds
#reds2
```






```{r}
rownames(reds) <- 1:nrow(reds)
reds
```


```{r}
colreds <- reds %>% separate(commodities, c("one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen"), "," ) 
```
```{r}
colSums(is.na(colreds))
```
```{r}
reducedcol <- colreds %>% select(1:15)
```

```{r}
colSums(is.na(reducedcol))
```
```{r}
reducedcol
```


```{r}
noNA <- reducedcol %>% replace_na(list(four = "", five = "", six  = "", seven  = "", eight  = "", nine = "", ten  = "", eleven  = ""))
noNA[noNA == " NA"] <- ""
write.csv(noNA, file = "noNA2full.csv")
#View(noNA)
noNA
```
Here I write the file out so that I can create a tabular data set for the minerals

```{r}
outFull <- unite(noNA, commodities, 5:15, sep = ", ")
#write.csv(outFull, file = "outFull2.csv")
#outFull
```


Here I read in the new data set with the minerals separated out into individual columns.

```{r}
imported <- read.csv("inFull2.csv")
imported
```
I need to see the structure of the new data set
```{r}
str(imported)
```
Here I want to see how the totals of each mineral

```{r}
minerals <- c(colnames(imported[7:38]))
mined <- integer()
#count <- 0
for (names in minerals){
  mined <- c(mined, sum(imported[[names]]))
}
#mined
```
```{r}
#minerals
```
```{r}
#bonded <- rbind(minerals, mined)
#bonded
```


```{r}
totals <- data.frame(minerals, mined)
totals
```


```{r}
htot <- as.data.frame(t(totals$mined))
colnames(htot) <- minerals
htot
```



## Visualizations 

```{r}
barplot(totals$mined, names.arg = totals[,1], cex.names = 0.5, las = 2)
```


```{r}
#str(imported)
```


```{r}
corrdf <- imported %>% select(
  7:38
)
corrdf
```


```{r}
corrdfvalues <- cor(corrdf)
```


```{r}
corrplot(corrdfvalues, tl.srt = 45, tl.cex = .5)
```




```{r}
#write.csv(corrdf, file = "corrdf.csv")
factCorr <- read_csv("factoredCorrdf.csv")
str(factCorr)
```



```{r}
set.seed(123)
km.res <- kmeans(corrdf, 5, nstart = 25)
km.res$cluster
```

```{r}
#View(corrdf)
result  <- kmeans(corrdf, 5)
fviz_cluster(result, data = corrdf)
```






```{r}
mineralsAuAgPb <- lm(Gold ~ Silver + Lead, data = factCorr) 
mineralsAuAgPb
```
```{r}
summary(mineralsAuAgPb)
```
```{r}
anova(mineralsAuAgPb)
```


```{r}
plot(mineralsAuAgPb)
```
```{r}
coef(mineralsAuAgPb)
```


PCA#########################################################################
```{r}
pca <-prcomp(t(corrdf), scale. = TRUE)
plot(pca$x[,1], pca$x[,3])
rpca <- t(corrdf)
```
```{r}
# from https://www.google.com/search?client=firefox-b-1-e&q=principle+component+analysis+in+r#kpvalbx=_rN4qX7nDEtGF9PwP3vO4oAM88
pca.var <- pca$sdev^2
pca.var.per <- round(pca.var/sum(pca.var)*100, 1)
barplot(pca.var.per, main = "Min Plot", xlab = "Principle Component", ylab = "Percent Variation")

```
```{r}
#rpca <t(pca$x)
#View(pca)
```


```{r}

pca.data <- data.frame(Sample=rownames(pca$x),
                       X=pca$x[,1],
                       Y=pca$x[,2])

pca.data
#View(pca.data)
```


```{r}
ggplot(data=pca.data, aes(x=X, y=Y, label=Sample))+
  geom_text()+
  xlab(paste("PC1 - ", pca.var.per[1], "%", sep = ""))+
  ylab(paste("PC2 - ", pca.var.per[2], "%", sep = ""))+
  theme_bw()+
  ggtitle("My Mineral Graph")
```
```{r}
#pca$rotation[,1]
```


```{r}
loading_scores <- pca$rotation[,1]
gene_scores <- abs(loading_scores)
gene_scores_ranked <- sort(gene_scores, decreasing = TRUE)
gene_scores_ranked
#top_10_genes <- names(gene_scores_ranked[1:10])
#top_10_genes
```

```{r}
pca$rotation[top_10_genes,1]
```




#####################################################################################




Goodness of fit?






