---
title: "predicting_gold_presence"
author: "Matt Twigg"
date: "7/12/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Introduction  

	I used to live in the Black Hills and would go gold panning for relaxation. I never found any gold, unfortunately. It occurs to me that if I use data science techniques, I might be able to predict where to find gold. I plan to use data sets from https://mrdata.usgs.gov/mrds/geo-inventory.php for Lawrence County, South Dakota to predict whether gold can be found in the area of other minerals. If gold shows up with certain other minerals, I can narrow down the areas that I pan for gold. I will use support vector machine classification to predict gold or no gold.

My specific research question is “Can the presence of gold be predicted from the presence of other minerals?” The USGS is a great resource for understanding where minerals were found and what minerals were present.

This is a classification task. I will be predicting if the location has gold or not based on the minerals in that area. These data sets give latitude, longitude, and mineral data for given locations. I will create a train/test split to test for accuracy. The data sets have missing values, characters, and multiple pieces of information in single fields. The data will have to be cleaned and prepped in order to be useful. Multiple data sets will have to be combined into one data frame. Multiple rows will have to be dropped and only some fields selected. I will be using Rstudio to work with the data sets and storing the rmarkdown on GitHub. 

##Methods  

Libraries used
```{r}
library(ggplot2)
library(tidyverse)
library(dplyr)
library(corrplot)
library(factoextra)
library(e1071)
library(caret)
library(class)
library(gmodels)
```

Data read in from https://mrdata.usgs.gov/mrds/geo-inventory.php for Lawrence County, South Dakota.
```{r}
dn <- read.csv("deadwoodnorth.csv")
ds <- read.csv("deadwoodsouth.csv")
ld <- read.csv("lead.csv")
tn <- read_csv("tinton.csv")
sp <- read_csv("spearfish.csv")
```

Here I bind all the data frames into one data frame.

```{r}
sites <- rbind(dn, ds, ld, tn, sp)
```


I select only the fields that I will need from the sites data frame.

```{r}
s1 <- sites %>% select(
  dep_id,
  site_name,
  latitude,
  longitude,
  commod1,
  commod2,
  commod3,
)
```

I copy the data frame to s2.
```{r}
s2 <- data.frame(s1)
```

I have to change one of the columns to factor to make it match the other two commod columns.
```{r}
s2$commod2 <- as.factor(s2$commod2)
```

Here is the structure of the new data frame.
```{r}
str(s2)
```
I unite commod1, 2, and 3 into one column called commodities.
```{r}
s2com <- unite(s2, commodities, 5:7, sep = ", ")
#str(s2com)
```
I create a vector with TRUE or FALSE for the presence of gold in each row of the data frame.
```{r}
au <- str_detect(s2com$commodities, "Gold")
```

I add that column to the data frame.
```{r}
s2com1 <- cbind(s2com, au)
```

I reassemble the data frame with all gold mining in the first 299 rows of the data frame.
```{r}
reds2com <- subset(s2com1, au == TRUE)
reds2comF <- subset(s2com1, au == FALSE)
reds <- rbind(reds2com, reds2comF)
#reds
```




I give the rows numbers for easy reference.

```{r}
rownames(reds) <- 1:nrow(reds)
#reds
```
I separate out each mineral into its own column.

```{r}
colreds <- reds %>% separate(commodities, c("one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen"), "," ) 
```
I need to see which of the columns that I created are empty. 
```{r}
colSums(is.na(colreds))
```
Any columns that have 403 NAs can be cut.

```{r}
reducedcol <- colreds %>% select(1:15)
```



I replace NA with no spaces and write the file out to be worked on manually.
```{r}
noNA <- reducedcol %>% replace_na(list(four = "", five = "", six  = "", seven  = "", eight  = "", nine = "", ten  = "", eleven  = ""))
noNA[noNA == " NA"] <- ""
#noNA
```
Here I write the file out so that I can create a tabular data set for the minerals

```{r}
outFull <- unite(noNA, commodities, 5:15, sep = ", ")
#write.csv(outFull, file = "outFull2.csv")
#outFull
```

```{r}

```


Here I read in the new data set with the minerals separated out into individual columns.

```{r}
imported <- read.csv("inFull2.csv")
#imported 
```
I need to see the structure of the new data set
```{r}
str(imported)
#View(imported)
```
I also want to write out the lat/long data
```{r}
allLatLong <- imported[3:5]
latLong <- allLatLong[1:299,]
write.csv(latLong, file = "latLong.csv")
```


```{r}
#added <- colSums(imported[7:38])
#class(added)
```






## Visualizations  

I want to see  the sums of each mineral. Here is the count visualized. It looks like Gold, Silver, and Lead had the most observations
```{r}

colMinerals <- names(imported)
added <- colSums(imported[7:38])
totals1 <- data.frame(added)
totals2 <- t(totals1)
barplot(totals2, cex.names = 0.5, las = 2)
```
```{r}
#totals2
```


Here is how the top  three minerals compare to all the others added up.

```{r}
totalObsMined <- sum(totals1)
totalObsMined
```
```{r}
other <- totalObsMined - totals2[1] - totals2[2] - totals2[3]
other
```
```{r}
portions <- c(other, totals2[1], totals2[2], totals2[3])
mineObs <- c("other", "Gold", "Silver", "Lead")
pie(portions, labels = mineObs, main = "Occurences of minerals in all the mining operations")
```
I create a data frame with just the minerals for correlation, visualized in a correlation map
```{r}
corrdf <- imported %>% select(
  7:38
)
corrdfvalues <- cor(corrdf)
corrplot(corrdfvalues, tl.srt = 45, tl.cex = .5)
```





```{r}
set.seed(123)
tabImp <- imported[7:38]
km.res <- kmeans(tabImp, 10, nstart = 10)
km.res$cluster
```

```{r}
#View(corrdf)
result  <- kmeans(tabImp, 20)
fviz_cluster(result, data = tabImp)
```
##Analysis##  



###Logistic regression###

```{r}
mineralsAuAgPb <- glm(Gold ~ Silver + Lead, data = tabImp) 
summary(mineralsAuAgPb)
```
```{r}
mineralAuAg <- glm(Gold ~ Silver, data = tabImp)
par(mfrow=c(2,2))
plot(mineralsAuAgPb, col = mineralsAuAgPb$Silver)
abline(mineralAuAg, col = "blue")
```
```{r}
mineralAuPb <- glm(Gold ~ Lead, data = imported)
par(mfrow=c(2,2))
plot(mineralAuPb, col=mineralAuAg$L)
abline(mineralAuPb, col = "blue")
```

```{r}
anova(mineralsAuAgPb)
```


```{r}
par(mfrow=c(2,2))
plot(mineralsAuAgPb)
```

```{r}
coef(mineralsAuAgPb)
```
###K nearest neighbor###  

```{r}
#knnDF <- imported[,c(8:38, 40)]
```

Guidance from https://rpubs.com/Drmadhu/IRISclassification
```{r}
divideImp <- createDataPartition(imported$targetMineral, times = 1, p = 0.7, list = FALSE)
```

```{r}
knnDF <- imported[,c(8:38, 40)]
knntrain<-knnDF[divideImp,]
knntest<-knnDF[-divideImp,]
knntrain2 <-knntrain[-32]
knntest2 <- knntest[-32]
```

```{r}
knnTrainLabels <- knntrain$targetMineral
knnTestLabels <- knntest$targetMineral
```
I train the model
```{r}
knnTestPred <- knn(train = knntrain2, test = knntest2, cl = knnTrainLabels, k  = 6, prob = TRUE)
```

```{r}
CrossTable(x = knnTestLabels, y = knnTestPred, prop.chisq = FALSE)
```
18/116 means a 16% error rate. 

###PCA###  

```{r}
pca <-prcomp(t(corrdf), scale. = TRUE)
plot(pca$x[,1], pca$x[,3])
rpca <- t(corrdf)
```
```{r}
# from https://www.google.com/search?client=firefox-b-1-e&q=principle+component+analysis+in+r#kpvalbx=_rN4qX7nDEtGF9PwP3vO4oAM88
pca.var <- pca$sdev^2
pca.var.per <- round(pca.var/sum(pca.var)*100, 1)
barplot(pca.var.per, main = "Min Plot", xlab = "Principle Component", ylab = "Percent Variation")

```
```{r}
#rpca <t(pca$x)
#View(pca)
```


```{r}

pca.data <- data.frame(Sample=rownames(pca$x),
                       X=pca$x[,1],
                       Y=pca$x[,2])

#pca.data
#View(pca.data)
```


```{r}
ggplot(data=pca.data, aes(x=X, y=Y, label=Sample))+
  geom_text()+
  xlab(paste("PC1 - ", pca.var.per[1], "%", sep = ""))+
  ylab(paste("PC2 - ", pca.var.per[2], "%", sep = ""))+
  theme_bw()+
  ggtitle("My Mineral Graph")
```
```{r}
#pca$rotation[,1]
```


```{r}
loading_scores <- pca$rotation[,1]
gene_scores <- abs(loading_scores)
gene_scores_ranked <- sort(gene_scores, decreasing = TRUE)
gene_scores_ranked
top_10_genes <- names(gene_scores_ranked[1:10])
top_10_genes
```

```{r}
pca$rotation[top_10_genes,1]
```




#####################################################################################




Goodness of fit?


#############################################################################################
```{r}
redFC <- imported[7:39]
#redFC
```

```{r}
#redFC
```


```{r}
set.seed(123)
#redFC2 <- redFC[1:32]
#redFC2
redFC$MineralType <- as.factor(redFC$MineralType)
#redFC
```
```{r}
divider <- createDataPartition(redFC$MineralType, times = 1, p = 0.7, list = FALSE)
train<-redFC[divider,]
test<-redFC[-divider,]
str(train)
```




```{r}
svmModel <- svm(train$MineralType ~., data = train)
svmModel
```
```{r}
table(train$MineralType)
```
```{r}
outcome <- predict(svmModel, train)
table(Predicted = outcome, Tagged = train$MineralType)
```


```{r}
testOutcome <- predict(svmModel, test)
table(Predicted = testOutcome, Tagged = test$MineralType)
```




